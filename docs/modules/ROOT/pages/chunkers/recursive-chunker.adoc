= Recursive Character Chunker
:page-layout: article

== Overview

The Recursive Character Chunker provides more intelligent text splitting by using a hierarchy of separators. It attempts to split on the most meaningful separators first, falling back to less meaningful ones if needed.

== Installation

[source,xml]
----
<dependency>
    <groupId>io.jchunk</groupId>
    <artifactId>jchunk-recursive-character</artifactId>
    <version>${jchunk.version}</version>
</dependency>
----

[source,groovy]
----
implementation group: 'io.jchunk', name: 'jchunk-recursive-character', version: "${JCHUNK_VERSION}"
----


== Configuration

[source,java]
----
// using default config
RecursiveCharacterChunker chunker = new RecursiveCharacterChunker();

// with custom config
Config config = Config.builder()
        .chunkSize(10)
        .chunkOverlap(0)
        .delimiters(List.of(";"))
        .trimWhitespace(true)
        .keepDelimter(Delimiter.START)
        .build();

RecursiveCharacterChunker chunker = new RecursiveCharacterChunker();
----

=== Configuration Options

[cols="1,2,3", options="header"]
|===
| Option | Description | Default

| `chunkSize`
| Maximum number of characters per chunk.
Chunks may exceed this limit if the text cannot be split further.
| `100`

| `chunkOverlap`
| Number of characters to overlap between consecutive chunks.
Helps preserve context across boundaries.
| `20`

| `delimiters`
| Ordered list of **regex strings** used for splitting.
The chunker tries them in sequence; if none match, it falls back to the last (`""` = character-level).
| `["\n\n", "\n", " ", ""]`

| `keepDelimiter`
| Whether to keep delimiters in chunks:
- `NONE`: remove
- `START`: keep at start
- `END`: keep at end
| `START`

| `trimWhitespace`
| Whether to trim leading/trailing whitespace in each chunk.
| `true`
|===

=== Default Separators

The default separator hierarchy is:

. `\n\n` (double newlines)
. `\n` (single newlines)
. `\s` (single space)
. `` (empty string)

== Example

[source,java]
----
Config config = Config.builder().chunkSize(15).chunkOverlap(0).build();
RecursiveCharacterChunker chunker = new RecursiveCharacterChunker(config);
List<Chunk> chunks = chunker.split("split this text\n\nI need it\n to be done as soon as possible");

// Result: ["split this text", "I need it", "to be done as", "soon as", "possible"]
----

== Custom Separators

[source,java]
----
List<String> customSeparators = List.of("-", ".");
Config config = Config.builder()
        .chunkSize(5)
        .chunkOverlap(0)
        .separators(List.of("-", "."))
        .build();

RecursiveCharacterChunker chunker = new RecursiveCharacterChunker(config);
List<Chunk> chunks = chunker.split("");

// Result: ["give", "- me a", "_ hand"]

----

== Pros and Cons

=== Pros
* Easy to implement and understand
* More advanced than fixed chunking
* Predictable chunk sizes
* Fast processing

=== Cons
* Doesn't consider context
* May produce larger chunks than specified
* Overlap creates duplicate data